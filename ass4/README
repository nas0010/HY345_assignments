Για κάποιο λόγο δεν μου έτρεχε ο qemu οπότε δεν τέσταρα ποτέ όσα είχα σκεφτεί.
Παρακάτω έχω τον τρόπο υλοποίησης που θα ακολουθούσα αν έτρεχε ο qemu και δεν είχα 
απογοητευτεί τόσο εύκολα:)
Αρχικά θα δημιουργούσα τα Processes και με την set task params από την ασκ 3 θα έδινα 
το deadline και runtime.Έπειτα θα υπολόγιζα για κάθε μια το περιθώριο S και θα της έβαζα στην rq.
όπως είδα στο sched_rt.c με δυο συανρτήσεις disable runtime kai enable runtime θα έλεγχα
ποια διεργασία θα τρέχει.Κάθε διεργασία που δεν εκτελείται και το υπόλοιπο για να τελειώσει 
είναι μεγαλύετρο του 0 θα γίνεται ξαναά enqueue στην rq, ενώ αν κάποια το remaining time είναι αρνητικό θα γίενται dequeue και κιλλ. 
Η επιλογή για την επόμενη διεργασία θα γίνεται μέσω
μιας συνάρτησης pick next task η οποία θα παίρνει την rq θα παίρνει την διεργασία που 
βρίσκεται στην κορυφή και θα συγκρίνει το S της με όλων των υπολοίπωνκαι αν είναι το μικρότερο
θα ξεκινάει ένα timer για εκείνη και θα την τρέχει και θα θέτει μέσω ενός sched entity 
to exec_start me to clock_task ths rq.Μέσω της context switch  στην schedule() 
θα αλλάζει σε αυτήν(δεν νομίζω ότι χρειάζεται να αλλάξω κάτι απλάνα θέσω σωστά τα prev kai 
next) που επιλέχτηκε και θα θέτει ως prev αυτην που τρέχει εκείνητην στιγμή.

Ελπίζω να καταλάβατε έστω και λ΄γο πως το έχω στο μυαλό μου, ξέρω ότι η περιγραφή μου είναι
ανούσια χωρλις κάποια υλοποίηση.
